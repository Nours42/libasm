explication du process :

section .text indique que le code suivant doit etre place dans la section de
texte du fichier executable.

global _ft_strlen declare _ft_strlen comme un symbole global c'est comnme une
fonction globale qui peut donc etre appele dans d'autre fichiers (a l'assemblage)

la fonction commence par comparer rax avec rax et en stocke le resultat dans rax,
donc la difference etant forcement nulle, c'est une methode courante pour mettre
une valeur a 0.
rax est par convention la valeur de retour de la fonction.
jmp compare dit au programme, ensuit jump a la partie compare.

compare justement demande de compare si le pointeur situe a l'adresse
rdi + rax est de 0, 0 comme dans \0 ou EOF.
rdi par convention c'est le premier argument de la fonction, ici c'est un pointeur
vers le premier bit de la chaine de caracteres. (parce que c'est sous entendu
qu'on va utiliser ce programme avec un char*)

jne = jump if non egal, c'est le if not de la comparaison au dessus.
il remont a increment qui lui va faire rax++ ou plutot inc rax.

ainsi le programme reprend en descendant les lignes a compare qui va voir si
rdi + rax est la fin de la string ou pas et dans ce cas boucler jusqu'a la
fin et renvoye la valeur de rax

pour compiler :

1 / creer le fichier .o a partir du .s : nasm -f elf64 ft_strlen.s -o ft_strlen.o
2 / creer une librairie qui va contenir ce .o : ar rcs libasm.a ft_strlen.o
3 / on compile en precisant le librairie : gcc -Wall -Werror -Wextra main.c -L. -lasm -o test